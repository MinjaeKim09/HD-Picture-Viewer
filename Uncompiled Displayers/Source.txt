[i]HDPICV
[i]"99999999999999999BBBBBBBBBBBBBB99B999999999999B99B99999999BBB9B99B99999999BBB9B99B99999999BBB9B99B999999999999B99B999B99999999B99B99BBB9999999B99B9BBBBB999B99B99B9BBBBBB9BBB9B99B9BBBBBBBBBB9B99B999999999999B99BBBBBBBBBBBBBB99BBBBBBBBBBBBBB99999999999999999"
[i]High Definition Picture Viewer                    By TLM
//dbd(0
//WARNING: the following code is so horrible, it crashed the ICE debugger and froze CEmu! :P
0->APOS
0->KEY
0->PAGE
0->TOTALPICS
10->THUMBNAILX
20->THUMBNAILY
0->RECTX
10->RECTY
1->SELECTEDPIC
//this code resized the full image to thumbnail-size 
DefineSprite(40,60->THUMBNAIL
DefineSprite(160,320

//Main loop
While KEY!=15
//detects images
	Call DETECTPICS
	//displays the thumbnails
	Call DISPTHUMB
	//loads the selection GUI
	Call SELECTOR
End
Goto STOP

Lbl DETECTPICS
0->TOTALPICS
sum(0)
// Allocate memory for picture names
Alloc(9)->LPICNAME
Alloc(9)->RPICNAME
//palettes
Alloc(9)->LPICPAL
Alloc(9)->RPICPAL

Alloc(256)->PALNAME

0->LPOS

While Detect(^^oLPOS,"HDPICV3L"->LPIC
	// Open the variable - we are sure it exists because it's detected
    Open(LPIC,"r")->LPICSLOT

	//get palette to name
	//Seek(7,0,LPICSLOT
	//Read(LPICPAL,7,1,LPICSLOT
	//search for it
	//0->LPALPOS
	//While Detect(^^oLPALPOS,"Z"+LPICPAL->LPAL
	//	Open(LPAL,"r")->LPALSLOT
	
	//	Read(LPALNAME,256,1,LPALSLOT
	//End
	
		
	// Write the name to the allocated memory
	Seek(8,0,LPICSLOT
	Alloc(9)->LPICNAME
	Read(LPICNAME,8,1,LPICSLOT
		
	// Detect right half of the images
	0->RPOS
	While Detect(^^oRPOS,"HDPICV3R"->RPIC
        // Open the variable - we are sure it exists because it's detected
		Open(RPIC,"r"->RPICSLOT

		// Write the name
		Seek(8,0,RPICSLOT
		Read(RPICNAME,8,1,RPICSLOT

		// Compare names compare returns 0 if true
		If not([Med]LPICNAME,RPICNAME
			// Yay, they matched!			
			//store right palette to mem
			//get palette name
			//Seek(8,0,RPICSLOT
			//Read(RPICPAL,7,1,RPICSLOT
			//search for it
			0->PALPOS
			While Detect(^^oPALPOS,"HDPALV1B"->PAL
				Open(PAL,"r")->PALSLOT
				Seek(8,0,PALSLOT
				Read(PALNAME,8,1,PALSLOT
				If not([Med]LPICNAME,PALNAME
					//Now store the data pointer into L1
					TOTALPICS+3->TOTALPICS
					
            		GetDataPtr(LPICSLOT)->L1(TOTALPICS
					GetDataPtr(RPICSLOT)->L2(TOTALPICS
					GetDataPtr(PALSLOT)->L3(TOTALPICS
					//gets name of the pictures
					LPICNAME->L4(TOTALPICS
					//gets size of the pictures
					//GetSize(LPICSLOT)+GetSize(RPICSLOT)->L5(TOTALPICS		
					//dbd(0
										
				End
			End
		End
		// Close the right half of the image
		Close(RPICSLOT
	End
	// Close the left half of the image
	Close(LPICSLOT
End
//end of Detect( LPIC

Return
//go back to the main loop


//NOTES FOR NEW THUMBNAIL ROUTINE
//[MateoC] Each pixel is given 3 color components, known as red (R), green (G), and blue (B)
//[MateoC] On the CE, these are derived from a palette. An image has a palette, and the screen has a different palette.
//[MateoC] What we want to do is make the colors in the image palette match as close as possible to the screen palette
//[MateoC] This is so the colors look good when different images are using different palettes
//[MateoC] In your case, the xlib palette is the screen palette 
//[MateoC] Now, for every pixel in the image, we grab the palette entry associated with it
//[MateoC] Images are stored in bytes, so if a byte is 2, it means it is using entry 2 of the palette (starting from 0)
//[MateoC] Palette entries are 16 bits, formatted as 1555
//[MateoC] This means that 1 bit green, 5 bits red, 5 bits green, 5 bits blue
//[Runer112] (that's not what it's supposed to mean, but that's what it does mean for the CE)
//[MateoC] The 1 bit green actually is a part of the 5 bits green, resulting in a 565 r,g,b color 
//[MateoC] So what we do is we get each component of red, blue, and green into variables. We'll call them R1, G1, B1
//[MateoC] Now, we have to search the screen (xlib) palette for a color that matches best these R1, G1, B1 values
//[MateoC] Starting at the first entry in the palette, we get the color components for the xlib color. We'll call this R2, G2, B2
//[MateoC] Now, we use a fancy thing called the Euclidean distance between these two colors. It's a straightforward formula that looks like this:
//sqrt((R1 -R2)^2 + (G1 - G2)^2 + (B1 - B2)^2)
//[MateoC] Then we loop through the screen palette for every R2, G2, and B2 color, and whichever one results in the smallest Euclidean distance is the palette entry we use, and draw to the screen
//[MateoC] So if the original image's pixel is 2, we rewrite it to the screen as a different value which matches the palette entry
//[MateoC] Okay I'm done

//[TLM] So you're taking the custom palette and trying to substitute it for a standard palette.

//displays thumbnails
Lbl DISPTHUMB
det(0


//set up for text
//normal text size
SetTextScale(1,1
//background text white
SetTextBGColor(255
//text black
SetTextFGColor(0

//if no pictures are detected
If TOTALPICS=0
	det(18," Warning: No Pictures Detected!",50,1
End

//divides total pics by 3 to get the correct number of half-pictures detected
//TOTALPICS/3->SIMPLETOTAL
//initializes the I for the loop
1->I
//Loops until the screen has been filled with a max of 6 pictures (6>=I) or if there are no more pictures to display ((I*3)=<TOTALPICS)

While 6>=I and (I*3+18*PAGE)<=TOTALPICS
	//dbd(0
	//This stores the pic data for the halves into L and RPIC
	L1(I*3+18*PAGE)->LPIC
	L2(I*3+18*PAGE)->RPIC
	L3(SELECTEDPIC*3+18*PAGE)->PAL
	//image name
	L4(I*3+18*PAGE)->HEADERTEXT
	//sets the palette for the thumbnail
	det(4,PAL,512,0
	//image size
	//L4(I*3+18*PAGE)->IMAGESIZE
	//This is the math that determines where the image half will be placed
	//10 so there's some buffer between the image and edge of screen
	//150 because the images need to have space between them,
	//(remainder(I,2)=0)->LPICX This checks if the image should be placed on the left part of the screen or the right part (so they don't overlap) it stores the result into LPICX
	//LPICX-20+*{LPIC}/2->RPICX This takes which part of the screen it should be on, and adds on some x space so the 2 halves are directly next to eachother.
	75+90*not(remainder(I,2))->LPICX+40->RPICX
	//70*((I-1)/2) This adds on 70 to the Y placement if the image is the third, through sixth image. This makes sure the images don't overlap. It stores the result in LPICY and RPICY since the Y values aren't different
	10+70*((I-1)/2)->LPICY->RPICY

	
	5+245*not(remainder(I,2))->TEXTX
	12+70*((I-1)/2)->TEXTY

	//prints out the image name
	PrintStringXY(HEADERTEXT,TEXTX,TEXTY
	//PrintStringXY(IMAGESIZE,TEXTX,(TEXTY+10))

	//This is notes for a future palette
	//[P_T] Otherwise you won't have enough memory allocated for the biggest zoom sprite
//5:12:54 PM [#] [P_T] Set width and height of image using W->*{DATA} \ H->*{DATA+1} and use ScaleSprite(
	//5:12:23 PM [#] [P_T] Then, loop like 20 times to scale and do this:

	
	//scales left half
	ScaleSprite(LPIC,THUMBNAIL)
	//displays left half
	Sprite_NoClip(THUMBNAIL,LPICX,LPICY)
	//scales right half
	ScaleSprite(RPIC,THUMBNAIL)
	//displays right half
	Sprite_NoClip(THUMBNAIL,RPICX,RPICY)
	
	
	//increments I so the code doesn't keep displaying the same image
	I+1->I
End
//makes sure the rest of the graphics aren't effected by the custom palettes
det(3)

// end of While loop
Return

Lbl DIRECTIONS
//sets color to black
SetColor(0
//makes a black bar at the bottom of the screen, options will be shown there
FillRectangle_NoClip(0,225,320,15

//doubles text size
SetTextScale(2,2
//background black
SetTextBGColor(0
//text white
SetTextFGColor(214
PrintStringXY("<-",0,225
PrintStringXY("-\>",294,225
Return

//selection GUI
Lbl SELECTOR

//arrows GUI
Call DIRECTIONS



//SetColor(18
//This code moves around the selection box
While KEY!=15
	getKey->KEY
	//only exectued when a key is pressed
	If KEY!=0
		//sets color to white
		SetColor(255
		//clears the rectangular selector
		Rectangle_NoClip(RECTX,RECTY,155,60)
		//detects if the left or right arrow keys are pressed and updates the rectangle coordinates
		(((KEY=3) and (RECTX=0))-((KEY=2) and (RECTX=165)))->XPOS
		165*XPOS+RECTX->RECTX
		XPOS+SELECTEDPIC->SELECTEDPIC
		
		//detecs if the up or down arrow keys are pressed and updates the rectangle coordinates 
		(((KEY=1) and (RECTY<150))-((KEY=4) and (RECTY>=80)))->YPOS
		70*YPOS+RECTY->RECTY
		YPOS*2+SELECTEDPIC->SELECTEDPIC
		//sets color back to blue
		SetColor(18
		
		//detects if y= or graph keys are pressed and changes PAGE accordingly
		If KEY=53 or KEY=49
			(KEY=49 and PAGE<(TOTALPICS/18))-(KEY=53 and PAGE>0)+PAGE->PAGE
			Call DISPTHUMB
			det(3
		End
		
		//if enter was pressed
		If (KEY=9 or KEY=54) and SELECTEDPIC*3+18*PAGE<=TOTALPICS
			//stores the selection into a restorer variable
			SELECTEDPIC->ORIGSELECTED
			//stores the picture selected the +6*PAGE accounts for multiple pages
			L1(SELECTEDPIC*3+18*PAGE)->LPIC
			L2(SELECTEDPIC*3+18*PAGE)->RPIC
			L3(SELECTEDPIC*3+18*PAGE)->PAL
			det(5,0
			det(4,PAL,512,0
			Sprite_NoClip(LPIC,0,0)
			Sprite_NoClip(RPIC,*{LPIC},0)

			While KEY!=15
			//Gets the correct picture that was selected into L and RPIC
				getKey->KEY
				//Broke
				If (KEY=53 or KEY=2) and SELECTEDPIC+18*PAGE>1
					SELECTEDPIC-1->SELECTEDPIC
					If remainder(SELECTEPIC,6)=0 and PAGE>0
						PAGE-1->PAGE
						SELECTEDPIC+6->SELECTEDPIC
					End
					
				End

				If (KEY=49 or KEY=3) and SELECTEDPIC*3+18*PAGE<TOTALPICS
					SELECTEDPIC+1->SELECTEDPIC
					//dbd(0)
					If remainder(SELECTEPIC,6)=0 and (PAGE<(TOTALPICS/3)/6)
						PAGE+1->PAGE
						SELECTEDPIC-6->SELECTEDPIC
					End
				End

				//displays the picture
				If KEY
					L1(SELECTEDPIC*3+18*PAGE)->LPIC
					L2(SELECTEDPIC*3+18*PAGE)->RPIC
					L3(SELECTEDPIC*3+18*PAGE)->PAL
						det(5,0
						det(4,PAL,512,0
					Sprite_NoClip(LPIC,0,0)
					Sprite_NoClip(RPIC,*{LPIC},0)
				End
				
			End
			//restores selected pic so the selector will open the correct pic
			ORIGSELECTED->SELECTEDPIC
			Call DISPTHUMB
			det(3
			//makes sure the program wont quit
			0->KEY
		End

		//outputs arrows GUI
		Call DIRECTIONS
	End
	//displays the rectangle selector
	Rectangle_NoClip(RECTX,RECTY,155,60)
	
End
//end of while loop

Return
//go back to main loop

//ends the program
Lbl STOP
CloseAll
det(1
